[bits 64]   ; вказує, що программа написана для 64-ти бітного процесора

extern ExitProcess      ; підключення бібліотеки для успішного виходу з программи
extern GetStdHandle     ; підключення бібліотеки для отримання ідетифікатора
extern WriteConsoleA    ; підключення бібліотеки для виводу тексту в консольку

section .bss    ; секція для змінних значення який ми не знаєм
    dummy resq 1    ; змінна куди запишеться лог про успішний вивід в консоль

section .data   ; секція для ініціалізації змінних
    msg_1 db "Calculating...", 13, 10   ; змінна яка тримає в собі строку, яка буде виводитись в консоль/термінал. 13, для переходу на новий рядок. аналогія: "\n{13}Calculating...\n{10}"
    msg_len_1 equ $ - msg_1             ; змінна яка тримає значення кількості символів строки msg_1
    msg_2 db "All done!", 13, 10        ; змінна яка тримає в собі іншу строку, логіка та сама
    msg_len_2 equ $ - msg_2             ; змінна яка трримає в собі значення кількості символів строки msg_2


section .text   ; секція яка покаже лінкеру де буде починатись виконання програми
    global _start   ; оголошення початку програми для лінкера   

_start:     ; початок программи
    sub rsp, 40     ; виділення 40б пам'яті для використання бібліотек

    mov rcx, -11        ; отримання доступу до екрану
    call GetStdHandle   ; отримання ідентифікатора, по дефу записується в регістр rax
    mov r12, rax        ; запис ідентифікатора з регістру rax в регістр r12

    mov r13, 0      ; задаємо значення регістру r13 - 0
    mov r14, 3      ; задаємо значення регістру r14 - 3
check_loop:     ; мітка де починається цикл while
    cmp r13, r14    ; умовний if який порівнює регістри r13 і r14
    je equal    ; читається - "якщо регістри r13 і r14 рівні то стрибнути в блок коду equal"

    ; цей блок коду виконується якщо минула команда повертає значення FALSE

    mov rcx, r12                ; запис в регістр виходу ідентифікатора який отримали командою вище ^. це значення повинно бути саписане саме в цей регістр!
    mov r8, msg_len_1           ; записа в регістр r8 кількість символів які повинні бути виведені. САМЕ В r8
    lea rdx, [rel msg_1]        ; запис в rdx адрессу за якою знаходиться текст повідомлення
    lea r9, [rel dummy]         ; запис в r9 адрессу за якою запишеться лог про успішний вивід тексту
    mov qword [rsp + 32], 0     ; не помню шо це таке ;(
    
    call WriteConsoleA          ; виклик функції виводу тексту

    add r13, 1  ; додаємо до регістру r13 одиничку

    jmp check_loop  ; повернення до прапорця cheak_loop
equal:      ; прапорець equal той самий
    ; ця частина коду виконується якщо умовний if повертає TRUE
    mov rcx, r12                ; запис в регістр виходу ідентифікатора який отримали командою вище ^. це значення повинно бути саписане саме в цей регістр!
    mov r8, msg_len_2           ; записа в регістр r8 кількість символів які повинні бути виведені. САМЕ В r8
    lea rdx, [rel msg_2]        ; запис в rdx адрессу за якою знаходиться текст повідомлення
    lea r9, [rel dummy]         ; запис в r9 адрессу за якою запишеться лог про успішний вивід тексту
    mov qword [rsp + 32], 0     ; не помню шо це таке ;(
    
    call WriteConsoleA          ; виклик функції виводу тексту

    jmp finish                  ; переміщуємось на прапорець finish

finish:     ; прапорець finish
    xor rcx, rcx    ; очищення регістру rcx
    call ExitProcess    ; функція про закриття программи і успішне її завершення