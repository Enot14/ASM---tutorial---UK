[bits 64]   ; пояснення, що програма написана для 64-ти розрядного процессора

extern GetStdHandle ; імпорт бібліотеки для отримання ідентифікатора
extern ExitProcess  ; іморт для функції про завершення програми
extern WriteConsoleA

section .data
    msg db "Hello Pidari", 13, 10 ; визначення змінної і надання їй значення "Hello Pidari", також через числа 13, 10, якшощо дивитись на таблицю Таблиця ASCII, додається 2 пробіли
    ;db (Define Byte): Команда "запиши ці байти в пам'ять". Текст — це набір байтів
    msg_len equ $ - msg     ; обчислення кількості символів, принцип роботи щось типу воно є константою чере "equ" і воно від подоної адресси віднімає значення msg і далі по байтам якось за обчисленнями вичисляє кількість символів, пробіли також враховуються
    ; equ - константа


section .bss     ; секція для змінних значення який ми не знаємо, поки що
    dummy resq 1 ; створення змінної які ми далі запишем значення і виділаємо на це 8 байт і 1 блок. також ніби-то якщо виділити 2 блоки то буде 16 байт для цього

section .text       ; секція логіки(в минулих роботах описано це)
    global _start   ; показує лінкеру з якої команди починається программа

_start:             ; початок программи
    sub rsp, 40     ; виділення 40б для коректної роботи бібліотек

    mov rcx, -11        ; заносимо в регістр rcx значення -11, що є дефолтним для монітору ; запит на доступ до екрану
    call GetStdHandle   ; отрмуємо ідентифікатор монітору, значення записується в регістр rax
    mov r12, rax        ; значення з rax записуємо в r12

    mov rcx, r12                ; значення(індентифікатор) переносимо в регістр виходу - rcx    ; номер консолі
    lea rdx, [rel msg]          ; записуємо в регістр rdx адрессу змінної msg, тобто тексту який потрібно вивести   ; адресса тексту в пам'яті
    mov r8, msg_len             ; показуємо бібліотеці WriteConsoleA кількість символів які треба буде вивести, це як один з обов'язкових аргументів, хоча так і є   ; кількість байтів для виводу
    lea r9, [rel dummy]         ; записуємо в регістр r9 адрессу куди запишется лог про успішне виведення тексту   ; адресса для лога
    mov qword [rsp + 32], 0     ; Останній аргумент (завжди 0) кладемо ПІСЛЯ 32-байтної "тіні"

    call WriteConsoleA          ; довгожданний і мучаний вивід в консоль тексту
    
    xor rcx, rcx                ; очищення регістра виходу rcx
    call ExitProcess            ; повідомлення системі про закінчення программи

    